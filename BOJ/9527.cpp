/** 9527 1의 개수 세기 **/
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

long long a, b;
long long arr[55];

long long func(long long x)
{
    long long rt = x & 1; // 마지막 비트가 1이면 1을 더함
    for (long long i = 55; i > 0; i--)
    {
        // 3번째 비트가 1인 경우 1010 -> 1000=8=2^3
        // i번째 비트가 0이라면 continue
        if (!(x & (long long)1 << i))
            continue;
        rt += arr[i - 1] + (x - ((long long)1 << i) + 1);
        x -= (long long)1 << i;
    }
    return rt;
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> a >> b;

    // 누적합 구하기
    arr[0] = 1; // arr[k] = 최상위 비트가 k번 이하인 모든 수의 1의 개수
    // arr[2] : 1~111 (2^3-1)
    for (long long i = 1; i < 55; i++)
        arr[i] = arr[i - 1] * 2 + ((long long)1 << i);

    // cout << func(b) << '\n';
    // cout << func(a) << '\n';

    cout << func(b) - func(a - 1);
}

/*
a~b까지의 숫자 중 2진수로 1개수의 합
arr[a] = 1~a까지 숫자 중 1개수의 합
O(1)로 arr[a], arr[b]를 구해야 함.

0 0
1 1

2 10
3 11

4 100
5 101
6 110
7 111

08 1000
09 1001
10 1010
11 1011
12 1100
13 1101
14 1110
15 1111

0~1 : 0 + 1 = 1
2~3 : 0~1에서 1이 나온 개수에 1이 한 번씩 더 나옴 -> 0~3 : 1+1+2=4
4~7 : 0~7에서 1이 나온 개수에 1이 한 번씩 더 나옴 -> 0~7 : 4+4+4=12
8~15 : 1~7의 1개수가 반복되면서 1이 한 번씩 더 나옴 -> 0~15 : 0~7의 1의 개수(12) + 8~15사이의 숫자 개수(8) + 12 = 32
16~31 : 20+16=32

=> 11010과 같은 예시를 보면
0~1111까지의 개수는 미리 구해놓을 수 있음
그리고 제일 최상위 비트 1의 개수는 11010이라면 26이니까 26-16+1

그 다음 비트처리
1
...
01111 (여기까지 다 처리됨.)
10000
10001
11010

0~1010의 개수를 푸는 문제로 바뀜. 똑같이 구하고 그 다음 비트
그렇다면
1
...
111
1000
1001
1010

그 다음 비트는 0임. 0~0의 개수를 구하는 것과 같은 의미라서 continue

정리하자면 11010에서
1. arr[k] = 1~2^k 까지의 1의 개수를 저장해둔다.
- arr = {1, 1+1+2, 4+4+4, 12+12+8, ...}
2. 제일 왼쪽 비트부터 순환하며
    a. 0이면 continue
    b. 1이면
        현재 비트 순서 = i
        현재 숫자 = x 일 때
        arr[i-1] + x - 2^i + 1
3. 마지막 비트가 1이라면 1을 더한다.

최대 수가 10^16 대략 2^53

*/
